<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EasyLap Monitor</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #333;
        text-align: center;
      }
      .status {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      #console {
        background-color: #1e1e1e;
        color: #fff;
        padding: 10px;
        border-radius: 4px;
        font-family: monospace;
        height: 300px;
        overflow-y: auto;
        margin-top: 20px;
      }
      .button {
        background-color: #4caf50;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 0;
      }
      .button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .debug {
        color: #888;
      }
      .error {
        color: #ff6b6b;
      }
      .success {
        color: #4caf50;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>EasyLap Monitor</h1>
      <button id="connectButton" class="button">
        Connect to EasyLap Device
      </button>
      <div id="console"></div>
    </div>

    <script>
      const EASYLAP_PID = 0x86b9;
      let device = null;
      let dataBuffer = [];
      const consoleDiv = document.getElementById("console");
      const connectButton = document.getElementById("connectButton");

      const UART_CONFIG_REPORT_ID = 0x50;
      const UART_ENABLE_REPORT_ID = 0x41;

      // CP2110 UART Configuration Constants
      const UART_CONFIG = {
        BAUD_RATE: 38400,
        PARITY: 0, // None
        FLOW_CONTROL: 0, // Disabled
        DATA_BITS: 8,
        STOP_BITS: 0 // Short
      };

      function log(message, type = "") {
        const timestamp = new Date().toLocaleTimeString();
        const className = type ? ` class="${type}"` : "";
        consoleDiv.innerHTML += `<div${className}>[${timestamp}] ${message}</div>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
        console.log(`[${timestamp}] ${message}`);
      }

      function logDebug(message) {
        log(message, "debug");
      }

      function logError(message) {
        log(message, "error");
      }

      function logSuccess(message) {
        log(message, "success");
      }

      function arrayToHex(array) {
        if (!array || array.length === 0) return "empty";
        return Array.from(array)
          .map(b => b.toString(16).padStart(2, "0"))
          .join(" ");
      }

      function parseUartConfig(data) {
        if (!data || data.length < 9) {
          return null;
        }

        const baudRate =
          (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
        return {
          baudRate: baudRate,
          parity: data[4],
          flowControl: data[5],
          dataBits: data[6],
          stopBits: data[7]
        };
      }

      function displayUartConfig(config) {
        if (!config) {
          logError("Invalid UART configuration data");
          return;
        }

        logDebug("Current UART Configuration:");
        logDebug(`  Baud Rate: ${config.baudRate}`);
        logDebug(`  Parity: ${config.parity === 0 ? "None" : config.parity}`);
        logDebug(
          `  Flow Control: ${
            config.flowControl === 0 ? "Disabled" : config.flowControl
          }`
        );
        logDebug(`  Data Bits: ${config.dataBits}`);
        logDebug(`  Stop Bits: ${config.stopBits === 0 ? "Short" : "Long"}`);
      }

      async function getCurrentUartConfig() {
        try {
          const data = await device.receiveFeatureReport(UART_CONFIG_REPORT_ID);
          const config = parseUartConfig(data);
          if (config) {
            displayUartConfig(config);
          }
          return config;
        } catch (error) {
          logError(`Error getting UART config: ${error.message}`);
          return null;
        }
      }

      async function connectToDevice() {
        try {
          logDebug("Requesting EasyLap device...");
          const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: 0x10c4, productId: EASYLAP_PID }]
          });

          if (devices.length === 0) {
            logError("No device selected");
            return;
          }

          device = devices[0];
          logDebug(`Selected device: ${device.productName}`);
          await device.open();
          logSuccess("Connected to EasyLap device");

          // Configure UART
          const uartConfig = new Uint8Array([
            (UART_CONFIG.BAUD_RATE >> 24) & 0xff,
            (UART_CONFIG.BAUD_RATE >> 16) & 0xff,
            (UART_CONFIG.BAUD_RATE >> 8) & 0xff,
            UART_CONFIG.BAUD_RATE & 0xff,
            UART_CONFIG.PARITY,
            UART_CONFIG.FLOW_CONTROL,
            0x03,
            UART_CONFIG.STOP_BITS
          ]);
          logDebug(`Sending new UART config: ${arrayToHex(uartConfig)}`);
          await device.sendFeatureReport(UART_CONFIG_REPORT_ID, uartConfig);
          logSuccess("UART configured successfully");

          // Enable UART
          const enableUart = new Uint8Array([0x01]);
          logDebug(`Enabling UART: ${arrayToHex(enableUart)}`);
          await device.sendFeatureReport(UART_ENABLE_REPORT_ID, enableUart);
          logSuccess("UART enabled");

          // Set up input report listener
          device.addEventListener("inputreport", handleInputReport);
          logDebug("Input report listener set up");

          connectButton.disabled = true;
        } catch (error) {
          logError(`Error connecting to device: ${error.message}`);
          console.error("Connection error details:", error);
        }
      }

      function handleInputReport(event) {
        try {
          const data = new Uint8Array(event.data.buffer);
          logDebug(`Raw input report: ${arrayToHex(data)}`);

          // On Windows, the data might be padded with zeros
          // We need to find the actual data length by looking for the packet length byte
          let actualData = data;
          if (data.length > 0) {
            // Find the first non-zero byte that could be a valid packet length
            let startIndex = 0;
            while (
              startIndex < data.length &&
              (data[startIndex] === 0 ||
                (data[startIndex] !== 0x0b && data[startIndex] !== 0x0d))
            ) {
              startIndex++;
            }

            if (startIndex < data.length) {
              actualData = data.slice(startIndex);
              logDebug(`Trimmed to actual data: ${arrayToHex(actualData)}`);
            } else {
              logDebug("No valid packet start found in this report");
              return;
            }
          }

          // Add new data to buffer
          dataBuffer.push(...actualData);
          logDebug(`Current buffer size: ${dataBuffer.length} bytes`);

          // Process complete packets
          processBuffer();
        } catch (error) {
          logError(`Error processing input report: ${error.message}`);
          console.error("Input report error details:", error);
        }
      }

      function calculateChecksum(data) {
        let sum = 0;
        for (let i = 0; i < data.length; i++) {
          sum += data[i];
        }
        return sum & 0xff;
      }

      function processBuffer() {
        while (dataBuffer.length > 0) {
          // Need at least 1 byte to determine packet length
          if (dataBuffer.length < 1) return;

          const packetLength = dataBuffer[0];

          // Validate packet length
          if (packetLength !== 0x0b && packetLength !== 0x0d) {
            logDebug(
              `Invalid packet length: 0x${packetLength.toString(
                16
              )}, discarding first byte`
            );
            dataBuffer = dataBuffer.slice(1);
            continue;
          }

          // Check if we have enough data for the complete packet
          if (dataBuffer.length < packetLength) {
            logDebug(
              `Waiting for complete packet (need ${packetLength} bytes, have ${dataBuffer.length})`
            );
            return;
          }

          // Extract the complete packet
          const packet = dataBuffer.slice(0, packetLength);

          // Verify checksum
          const calculatedChecksum = calculateChecksum(packet.slice(0, -1));
          const receivedChecksum = packet[1];

          if (calculatedChecksum !== receivedChecksum) {
            logError(
              `Checksum mismatch: calculated 0x${calculatedChecksum.toString(
                16
              )}, received 0x${receivedChecksum.toString(16)}`
            );
            dataBuffer = dataBuffer.slice(1);
            continue;
          }

          // Process based on packet type
          if (packet[2] === 0x83) {
            // Timer packet
            const timerValue =
              packet[3] |
              (packet[4] << 8) |
              (packet[5] << 16) |
              (packet[6] << 24);
            logSuccess(`Timer: ${timerValue}`);
            logDebug(`Timer bytes: ${arrayToHex(packet.slice(3, 7))}`);
          } else if (packet[2] === 0x84) {
            // Car packet
            const uid = packet[3] | (packet[4] << 8);
            const timerValue =
              packet[7] |
              (packet[8] << 8) |
              (packet[9] << 16) |
              (packet[10] << 24);
            const hits = packet[11];
            const signalStrength = packet[12];
            logSuccess(
              `Car ${uid}: ${timerValue} (Hits: ${hits}, Signal: ${signalStrength})`
            );
            logDebug(`Car ID bytes: ${arrayToHex(packet.slice(3, 5))}`);
            logDebug(`Timer bytes: ${arrayToHex(packet.slice(7, 11))}`);
          } else {
            logDebug(`Unknown packet type: 0x${packet[2].toString(16)}`);
          }

          // Remove processed packet
          dataBuffer = dataBuffer.slice(packetLength);
        }
      }

      // Handle device disconnection
      navigator.hid.addEventListener("disconnect", event => {
        if (event.device === device) {
          logError("Device disconnected");
          if (device) {
            device.removeEventListener("inputreport", handleInputReport);
          }
          device = null;
          dataBuffer = [];
          connectButton.disabled = false;
        }
      });

      connectButton.addEventListener("click", connectToDevice);
    </script>
  </body>
</html>
